---
interface Article {
  id: string;
  title: string;
  category: string;
  tags: string[];
  status: 'published' | 'draft' | 'archived';
  createdAt: string;
}

interface Props {
  articles?: Article[];
}

let { articles = [] } = Astro.props;
const page = parseInt(Astro.url.searchParams.get('page') || '1');
const category = Astro.url.searchParams.get('category');
const tags = Astro.url.searchParams.getAll('tags');
const sort = Astro.url.searchParams.get('sort') || 'desc';
const status = Astro.url.searchParams.get('status');
const pageSize = 10;
const skip = (page - 1) * pageSize;
let hasNextPage = false;

// 如果没有通过 Props 传入数据，则尝试从 API 获取
if (articles.length === 0) {
  try {
    // 多获取一条以判断是否有下一页
    const fetchLimit = pageSize + 1;
    const params = new URLSearchParams();
    params.append('skip', skip.toString());
    params.append('limit', fetchLimit.toString());
    params.append('sort', sort);
    if (status && status !== 'all') params.append('status', status);
    if (category) params.append('category', category);
    tags.forEach(tag => params.append('tags', tag));

    const response = await fetch(`http://127.0.0.1:8000/api/admin/articles?${params.toString()}`);
    if (response.ok) {
      const data = await response.json();
      const mappedArticles = data.map((item: any) => ({
        id: item.id,
        title: item.title,
        category: typeof item.category === 'object' ? item.folder?.name : (item.folder || 'Uncategorized'),
        tags: Array.isArray(item.tags) ? item.tags.map((t: any) => typeof t === 'object' ? t.name : t) : [],
        status: item.status || (item.is_published ? 'published' : 'draft'),
        createdAt: item.date || (item.created_at ? new Date(item.created_at).toISOString().split('T')[0] : new Date().toISOString().split('T')[0]),
      }));

      if (mappedArticles.length > pageSize) {
        hasNextPage = true;
        articles = mappedArticles.slice(0, pageSize);
      } else {
        hasNextPage = false;
        articles = mappedArticles;
      }
    }
  } catch (e) {
    console.error("Failed to fetch articles from API", e);
  }
} else {
  hasNextPage = articles.length === pageSize;
}

const getPageUrl = (p: number) => {
  const params = new URLSearchParams(Astro.url.searchParams);
  params.set('page', p.toString());
  return `?${params.toString()}`;
};
---

<div class="article-list-card">
  <div class="card-header">
    <span>Article List</span>
    <span class="count" id="article-count">0 articles</span>
  </div>
  
  <div class="table-container">
    <table class="admin-table">
      <thead>
        <tr>
          <th class="col-title">Title</th>
          <th class="col-category">Category</th>
          <th class="col-tags">Tags</th>
          <th class="col-status">Status</th>
          <th class="col-date">Date</th>
          <th class="col-actions">Actions</th>
        </tr>
      </thead>
      <tbody id="article-table-body">
        <tr><td colspan="6" class="loading-text">Loading...</td></tr>
      </tbody>
    </table>
  </div>

  <div class="pagination-bar">
    <div class="pagination-controls">
      <a href="#" class="btn-page disabled" aria-label="Previous Page" id="prev-page-btn">
        <i class="fas fa-chevron-left"></i>
      </a>
      
      <div class="page-input-container">
        <input type="number" id="page-input" class="page-input" min="1" value="1" />
      </div>

      <a href="#" class="btn-page disabled" aria-label="Next Page" id="next-page-btn">
        <i class="fas fa-chevron-right"></i>
      </a>
    </div>
  </div>
</div>

<script>
  const pageInput = document.getElementById('page-input') as HTMLInputElement;
  const tbody = document.getElementById('article-table-body');
  const countSpan = document.getElementById('article-count');
  const prevBtn = document.getElementById('prev-page-btn') as HTMLAnchorElement;
  const nextBtn = document.getElementById('next-page-btn') as HTMLAnchorElement;
  
  // Store current articles data to avoid JSON serialization issues in HTML
  let currentArticlesData: any[] = [];

  // Function to update URL and fetch data
  function updatePage(page: number) {
    const url = new URL(window.location.href);
    url.searchParams.set('page', page.toString());
    window.history.pushState({}, '', url.toString());
    fetchAndRenderArticles();
  }

  if (pageInput) {
    pageInput.addEventListener('change', () => {
      let page = parseInt(pageInput.value);
      if (isNaN(page) || page < 1) page = 1;
      updatePage(page);
    });

    pageInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        pageInput.blur(); // Trigger change event
      }
    });
  }

  // Listen for filter changes from other components
  window.addEventListener('article-filter-change', () => {
    fetchAndRenderArticles();
  });

  // Handle browser back/forward
  window.addEventListener('popstate', () => {
    fetchAndRenderArticles();
  });

  // Initial fetch
  fetchAndRenderArticles();

  async function fetchAndRenderArticles() {
    if (!tbody) return;
    
    tbody.innerHTML = '<tr><td colspan="6" class="loading-text">Loading...</td></tr>';

    const urlParams = new URLSearchParams(window.location.search);
    const page = parseInt(urlParams.get('page') || '1');
    const pageSize = 10;
    const skip = (page - 1) * pageSize;
    
    // Construct API URL
    const fetchLimit = pageSize + 1;
    const apiParams = new URLSearchParams();
    apiParams.append('skip', skip.toString());
    apiParams.append('limit', fetchLimit.toString());
    
    const sort = urlParams.get('sort') || 'desc';
    apiParams.append('sort', sort);
    
    const status = urlParams.get('status');
    if (status && status !== 'all') apiParams.append('status', status);
    
    const category = urlParams.get('category');
    if (category) apiParams.append('category', category);
    
    const tags = urlParams.getAll('tags');
    tags.forEach(tag => apiParams.append('tags', tag));

    try {
      const response = await fetch(`http://127.0.0.1:8000/api/admin/articles?${apiParams.toString()}`);
      if (response.ok) {
        const data = await response.json();
        const mappedArticles = data.map((item: any) => ({
          id: item.id,
          title: item.title,
          category: typeof item.category === 'object' ? item.folder?.name : (item.folder || 'Uncategorized'),
          tags: Array.isArray(item.tags) ? item.tags.map((t: any) => typeof t === 'object' ? t.name : t) : [],
          status: (item.status === 'public' ? 'published' : item.status) || (item.is_published ? 'published' : 'draft'),
          createdAt: item.date || (item.created_at ? new Date(item.created_at).toISOString().split('T')[0] : new Date().toISOString().split('T')[0]),
        }));

        let articles = [];
        let hasNextPage = false;

        if (mappedArticles.length > pageSize) {
          hasNextPage = true;
          articles = mappedArticles.slice(0, pageSize);
        } else {
          hasNextPage = false;
          articles = mappedArticles;
        }
        
        // Update global data store
        currentArticlesData = articles;

        if (countSpan) countSpan.textContent = `${articles.length} articles (Page ${page})`;
        renderTable(articles);
        renderPagination(page, hasNextPage);
      } else {
        throw new Error('Failed to fetch');
      }
    } catch (e) {
      console.error("Failed to fetch articles", e);
      tbody.innerHTML = '<tr><td colspan="6" class="error-text">Failed to load articles.</td></tr>';
    }
  }

  function renderTable(articles: any[]) {
    if (!tbody) return;
    
    if (articles.length === 0) {
      tbody.innerHTML = '<tr><td colspan="6" class="loading-text">No articles found.</td></tr>';
      return;
    }

    tbody.innerHTML = articles.map(article => {
      return `
      <tr>
        <td class="col-title">
          <span class="title-text" title="${article.title}">${article.title}</span>
        </td>
        <td class="col-category">
          <span class="category-badge">${article.category}</span>
        </td>
        <td class="col-tags">
          <div class="tags-wrapper">
            ${article.tags.map((tag: string) => `<span class="tag-box">${tag}</span>`).join('')}
          </div>
        </td>
        <td class="col-status">
          <span class="status-badge status-${article.status}">
            ${article.status.charAt(0).toUpperCase() + article.status.slice(1)}
          </span>
        </td>
        <td class="col-date">
          <span class="date-text">${article.createdAt}</span>
        </td>
        <td class="col-actions">
          <button class="btn-icon edit" title="Edit" data-id="${article.id}"><i class="fas fa-edit"></i></button>
          <button class="btn-icon delete" title="Delete" data-id="${article.id}" data-title="${article.title}"><i class="fas fa-trash"></i></button>
        </td>
      </tr>
    `}).join('');
  }

  // Event Delegation for Actions
  if (tbody) {
    tbody.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      
      // Handle Edit
      const editBtn = target.closest('.btn-icon.edit');
      if (editBtn) {
        const id = editBtn.getAttribute('data-id');
        console.log('Edit button clicked for ID:', id);
        if (id) {
          // Find article data from memory instead of parsing HTML attribute
          // Note: id is string in HTML but might be number in data, handle comparison carefully
          const article = currentArticlesData.find(a => String(a.id) === String(id));
          console.log('Found article data:', article);
          if (article) {
            console.log('Dispatching open-edit-article-modal event');
            document.dispatchEvent(new CustomEvent('open-edit-article-modal', { detail: article }));
          } else {
            console.error('Article data not found for id:', id);
          }
        }
        return;
      }

      // Handle Delete
      const deleteBtn = target.closest('.btn-icon.delete');
      if (deleteBtn) {
        const id = deleteBtn.getAttribute('data-id');
        const title = deleteBtn.getAttribute('data-title');
        if (id && title) {
          window.deleteArticle(id, title);
        }
        return;
      }
    });
  }

  // Define global types for window functions
  declare global {
    interface Window {
      deleteArticle: (id: string, title: string) => void;
      showAdminAlert: (message: string, type?: 'error' | 'success' | 'info') => void;
    }
  }

  // Delete function
  window.deleteArticle = async (id: string, title: string) => {
    if (confirm(`Are you sure you want to delete "${title}"?`)) {
      try {
        const response = await fetch(`http://127.0.0.1:8000/api/admin/articles/${id}`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          if (window.showAdminAlert) {
            window.showAdminAlert('Article deleted successfully', 'success');
            // Refresh the list after a short delay
            setTimeout(() => {
              fetchAndRenderArticles();
              // Dispatch event to refresh filters (categories and tags)
              window.dispatchEvent(new CustomEvent('article-data-changed'));
            }, 1000);
          } else {
            alert('Article deleted successfully');
            fetchAndRenderArticles();
            window.dispatchEvent(new CustomEvent('article-data-changed'));
          }
        } else {
          throw new Error('Failed to delete');
        }
      } catch (e) {
        console.error("Delete error:", e);
        if (window.showAdminAlert) {
          window.showAdminAlert('Failed to delete article', 'error');
        } else {
          alert('Failed to delete article');
        }
      }
    }
  };

  function renderPagination(page: number, hasNextPage: boolean) {
    if (pageInput) pageInput.value = page.toString();

    if (prevBtn) {
      if (page > 1) {
        prevBtn.classList.remove('disabled');
        prevBtn.onclick = (e: MouseEvent) => { e.preventDefault(); updatePage(page - 1); };
      } else {
        prevBtn.classList.add('disabled');
        prevBtn.onclick = (e) => e.preventDefault();
      }
    }

    if (nextBtn) {
      if (hasNextPage) {
        nextBtn.classList.remove('disabled');
        nextBtn.onclick = (e: MouseEvent) => { e.preventDefault(); updatePage(page + 1); };
      } else {
        nextBtn.classList.add('disabled');
        nextBtn.onclick = (e) => e.preventDefault();
      }
    }
  }
</script>

<style>
  .article-list-card {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
    padding: 20px;
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    font-size: 18px;
    font-weight: 600;
    color: #303133;
  }

  .count {
    font-size: 14px;
    color: #909399;
    font-weight: normal;
  }

  .table-container {
    overflow-x: auto;
  }

  .admin-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
    table-layout: fixed;
  }

  .admin-table th {
    text-align: left;
    padding: 12px 16px;
    color: #909399;
    font-weight: 500;
    border-bottom: 1px solid #ebeef5;
    border-right: 1px solid #ebeef5;
  }

  .admin-table th:last-child {
    border-right: none;
  }

  /* Column Widths */
  .col-title { width: 25%; }
  .col-category { width: 15%; }
  .col-tags { width: 20%; }
  .col-status { width: 10%; }
  .col-date { width: 15%; }
  .col-actions { width: 15%; }

  /* Table Cells */
  .admin-table :global(td) {
    padding: 12px 16px;
    border-bottom: 1px solid #ebeef5;
    border-right: 1px solid #ebeef5;
    color: #606266;
    vertical-align: middle;
  }

  .admin-table :global(td:last-child) {
    border-right: none;
  }

  /* Title Column */
  .admin-table :global(td:first-child) {
    font-weight: 500;
    color: #303133;
  }

  :global(.title-text) {
    display: block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Badges & Tags */
  :global(.category-badge) {
    display: inline-block;
    padding: 2px 8px;
    background-color: #ecf5ff;
    color: #409eff;
    border-radius: 4px;
    font-size: 12px;
  }

  :global(.tags-wrapper) {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }

  :global(.tag-box) {
    display: inline-block;
    padding: 2px 6px;
    background-color: #f4f4f5;
    color: #909399;
    border-radius: 4px;
    font-size: 12px;
  }

  :global(.status-badge) {
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 12px;
    display: inline-block;
  }

  :global(.status-published) { background: #f0f9eb; color: #67c23a; }
  :global(.status-draft) { background: #fdf6ec; color: #e6a23c; }
  :global(.status-private) { background: #f4f4f5; color: #909399; }
  :global(.status-archived) { background: #f4f4f5; color: #909399; }

  /* Actions */
  :global(.btn-icon) {
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px 8px;
    font-size: 14px;
    transition: color 0.3s;
    margin-right: 4px;
  }

  :global(.btn-icon.edit) { color: #409eff; }
  :global(.btn-icon.edit:hover) { color: #66b1ff; }
  :global(.btn-icon.delete) { color: #f56c6c; }
  :global(.btn-icon.delete:hover) { color: #f78989; }

  /* Pagination */
  .pagination-bar {
    display: flex;
    justify-content: flex-end;
    padding-top: 20px;
  }

  .pagination-controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .btn-page {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border: 1px solid #dcdfe6;
    border-radius: 4px;
    background: white;
    color: #606266;
    text-decoration: none;
    transition: all 0.3s;
  }

  .btn-page:hover:not(.disabled) {
    color: #409eff;
    border-color: #c6e2ff;
    background-color: #ecf5ff;
  }

  .btn-page.disabled {
    color: #c0c4cc;
    cursor: not-allowed;
    background-color: #f4f4f5;
    border-color: #e4e7ed;
  }

  .page-input-container {
    display: flex;
    align-items: center;
  }
  
  .page-input {
    width: 40px;
    height: 32px;
    text-align: center;
    border: 1px solid #dcdfe6;
    border-radius: 4px;
    color: #606266;
    outline: none;
    transition: border-color 0.2s;
  }
  
  .page-input:focus {
    border-color: #409eff;
  }

  :global(.loading-text), :global(.error-text) {
    text-align: center;
    padding: 20px;
    color: #909399;
  }
  :global(.error-text) { color: #f56c6c; }
</style>
